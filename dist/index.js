function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{Promise.resolve(value).then(_next,_throw)}}function _async_to_generator(fn){return function(){var self=this,args=arguments;return new Promise(function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value)}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err)}_next(undefined)})}}function _ts_generator(thisArg,body){var f,y,t,g,_={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]};return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}}import{existsSync}from"fs";import*as core from"@actions/core";import{isArray}from"./assertion";import{context,parseConfig}from"./config";import Git from"./git";import{forEach,dedent,addTrailingSlash,pathIsDirectory,copy,remove}from"./helpers";var COMMIT_PREFIX=context.COMMIT_PREFIX,OVERWRITE_EXISTING_PR=context.OVERWRITE_EXISTING_PR,DRY_RUN=context.DRY_RUN,COMMIT_EACH_FILE=context.COMMIT_EACH_FILE,SKIP_CLEANUP=context.SKIP_CLEANUP,TMP_DIR=context.TMP_DIR,SKIP_PR=context.SKIP_PR,ASSIGNEES=context.ASSIGNEES,PR_LABELS=context.PR_LABELS;var run=function(){var _ref=_async_to_generator(function(){var git,repos;return _ts_generator(this,function(_state){switch(_state.label){case 0:git=new Git;return[4,parseConfig()];case 1:repos=_state.sent();return[4,forEach(repos,function(){var _ref=_async_to_generator(function(param){var repo,files,existingPr,_tmp,modified,_,hasChanges,changedFiles,pullRequest,err;return _ts_generator(this,function(_state){switch(_state.label){case 0:repo=param.repo,files=param.files;core.info("Repository Info");core.info("Slug: ".concat(repo.name));core.info("Owner: ".concat(repo.user));core.info("Https Url: https://".concat(repo.fullName));core.info("Branch: ".concat(repo.branch));core.info("	");_state.label=1;case 1:_state.trys.push([1,24,,25]);return[4,git.initRepo(repo)];case 2:_state.sent();if(!!SKIP_PR)return[3,8];return[4,git.createPrBranch()];case 3:_state.sent();if(!OVERWRITE_EXISTING_PR)return[3,5];return[4,git.findExistingPr()];case 4:_tmp=_state.sent();return[3,6];case 5:_tmp=undefined;_state.label=6;case 6:existingPr=_tmp;if(!(existingPr&&!DRY_RUN))return[3,8];core.info("Found existing PR ".concat(existingPr.number));return[4,git.setPrWarning()];case 7:_state.sent();_state.label=8;case 8:core.info("Locally syncing file(s) between source and target repository");modified=[];return[4,forEach(files,function(){var _ref=_async_to_generator(function(param){var source,dest,replace,exclude,fileExists,localDestination,destExists,isDirectory,hasChanges,directory,otherFiles,message,_message_String,commit,pr;return _ts_generator(this,function(_state){switch(_state.label){case 0:source=param.source,dest=param.dest,replace=param.replace,exclude=param.exclude;fileExists=existsSync(source);if(!fileExists)return[2,core.warning("Source ".concat(source," not found"))];localDestination="".concat(git.workingDir,"/").concat(dest);destExists=existsSync(localDestination);if(destExists&&!replace)return[2,core.warning("File(s) already exist(s) in destination and 'replace' option is set to false")];return[4,pathIsDirectory(source)];case 1:isDirectory=_state.sent();if(isDirectory)core.warning("Source is directory");return[4,copy(isDirectory?"".concat(addTrailingSlash(source)):source,localDestination,isDirectory,exclude)];case 2:_state.sent();return[4,git.add(dest)];case 3:_state.sent();if(!(COMMIT_EACH_FILE===true))return[3,6];return[4,git.hasChanges()];case 4:hasChanges=_state.sent();if(!hasChanges)return[2,core.debug("File(s) already up to date")];core.debug("Creating commit for file(s) ".concat(dest));directory=isDirectory?"directory":"";otherFiles=isDirectory?"and copied all sub files/folders":"";message={true:{commit:"".concat(COMMIT_PREFIX," Synced local '").concat(dest,"' with remote '").concat(source,"'"),pr:"Synced local ".concat(directory," <code>").concat(dest,"</code> with remote ").concat(directory," <code>").concat(source,"</code>")},false:{commit:"".concat(COMMIT_PREFIX," Created local '").concat(dest,"' from remote '").concat(source,"'"),pr:"Created local ".concat(directory," <code>").concat(dest,"</code> ").concat(otherFiles," from remote ").concat(directory," <code>").concat(source,"</code>")}};_message_String=message[String(destExists)],commit=_message_String.commit,pr=_message_String.pr;return[4,git.commit(commit)];case 5:_state.sent();modified.push({dest:dest,source:source,message:pr});_state.label=6;case 6:return[2]}})});return function(_){return _ref.apply(this,arguments)}}())];case 9:_state.sent();if(!DRY_RUN)return[3,11];core.warning("Dry run, no changes will be pushed");core.debug("Git Status:");_=core.debug;return[4,git.status()];case 10:_.apply(core,[_state.sent()]);return[2];case 11:return[4,git.hasChanges()];case 12:hasChanges=_state.sent();if(!(hasChanges===false&&modified.length<1))return[3,15];core.info("File(s) already up to date");if(!existingPr)return[3,14];return[4,git.removePrWarning()];case 13:_state.sent();_state.label=14;case 14:return[2];case 15:if(!(hasChanges===true))return[3,17];core.debug("Creating commit for remaining files");return[4,git.commit()];case 16:_state.sent();if(git.workingDir)modified.push({dest:git.workingDir});_state.label=17;case 17:core.info("Pushing changes to target repository");return[4,git.push()];case 18:_state.sent();if(!!SKIP_PR)return[3,23];changedFiles=dedent("\n					<details>\n					<summary>Changed files</summary>\n					<ul>\n					".concat(modified.map(function(file){return"<li>".concat(file.message,"</li>")}).join(""),"\n					</ul>\n					</details>\n				"));return[4,git.createOrUpdatePr(COMMIT_EACH_FILE?[changedFiles]:[])];case 19:pullRequest=_state.sent();core.info("Pull Request #".concat(pullRequest.number," created/updated: ").concat(pullRequest.html_url));core.setOutput("pull_request_number",pullRequest.number);core.setOutput("pull_request_url",pullRequest.html_url);if(!(isArray(PR_LABELS)&&PR_LABELS.length>0))return[3,21];core.info('Adding label(s) "'.concat(PR_LABELS.join(", "),'" to PR'));return[4,git.addPrLabels(PR_LABELS)];case 20:_state.sent();_state.label=21;case 21:if(!(isArray(ASSIGNEES)&&ASSIGNEES.length>0))return[3,23];core.info('Adding assignee(s) "'.concat(ASSIGNEES.join(", "),'" to PR'));return[4,git.addPrAssignees(ASSIGNEES)];case 22:_state.sent();_state.label=23;case 23:core.info("	");return[3,25];case 24:err=_state.sent();core.error(err.message);core.error(err);return[3,25];case 25:return[2]}})});return function(_){return _ref.apply(this,arguments)}}())];case 2:_state.sent();if(SKIP_CLEANUP===true){core.info("Skipping cleanup");return[2]}return[4,remove(TMP_DIR)];case 3:_state.sent();core.info("Cleanup complete");return[2]}})});return function run(){return _ref.apply(this,arguments)}}();run().then(function(){}).catch(function(e){core.error("ERROR",e);core.setFailed(e.message)});